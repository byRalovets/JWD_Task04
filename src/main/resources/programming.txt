Определение задач.

Поток выполняет некоторую задачу, поэтому вам нужны средства для описания
таких задач. Эти средства предоставляются интерфейсом Runnable. Чтобы
определить задачу, просто реализуйте Runnable и напишите метод run(),
который выполнит нужные действия.

Например, следующая задача LiftOff выводит обратный отсчет перед запуском:

//: concurrency/LiftOff.java
// Demonstration of the Runnable interface.

public class LiftOff implements Runnable {
    protected int countDown = 10; // Default
    private static int taskCount = 0;
    private final int id = taskCount++;
    public LiftOff() {}
    public LiftOff(int countDown) {
        this.countDown = countDown;
    }
    public String status() {
        return "#" + id + "(" +
            (countDown > 0 ? countDown : "Liftoff!") + " ) , ";
    }
    public void run() {
        while(countDown-- > 0) {
            System.out.print(status());
            Thread.yield();
        }
    }
} ///:~

Идентификатор id различает экземпляры задачи. Он объявлен с ключевым словом
final, потому что значение не должно изменяться после инициализации.

Метод run() практически всегда являет собой некоторый цикл, который выполняется,
пока поток еще нужен, поэтому вам придется определить условие выхода из такого
цикла (можно просто использовать команду return, как сделано в рассматриваемой
программе). Зачастую метод run() реализуется в форме бесконечного цикла; это значит,
что завершение потока осуществляется с помощью какого-либо внешнего фактора или
он будет выполняться бесконечно (чуть позже в этой главе вы узнаете, как безопасно
сигнализировать потоку, чтобы он «остановился»).

Вызов статического метода Thread.yield() внутри run() является рекомендацией для
планировщика потоков (подсистема механизма потоков Java, которая переключает
процессор с одного потока на другой). По сути она означает: «Важная часть моего
цикла выполнена, и сейчас было бы неплохо переключиться на другую задачу». Этот
вызов полностью необязателен, но он используется здесь, потому что с ним результат
получается более интересным: вы с большей вероятностью увидите доказательства
переключения потоков.

В следующем примере вызов run() не управляется отдельным потоком; метод просто
напрямую вызывается в main() (поток, конечно, при этом используется: тот, который
всегда создается для main()):

//: concurrency/MainThread.java
public class MainThread {
    public static void main(String[] args) {
        LiftOff launch * new LiftOff();
        launch.run();
    }
} /* Output:
#0(9), #0(8), #0(7), #0(6), #0(5), #0(4), #0(3), #0(2),
#0(1), tt0(LiftoffI),
*///:~

Класс, производный от Runnable, должен содержать метод run(), но ничего особенного
в этом методе нет — он не обладает никакими «встроенными» потоковыми способностями.
Чтобы добиться потокового выполнения, необходимо явно присоединить
задачу к потоку.

